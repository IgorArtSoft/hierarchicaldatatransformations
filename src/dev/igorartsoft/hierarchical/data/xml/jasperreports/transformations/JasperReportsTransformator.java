package dev.igorartsoft.hierarchical.data.xml.jasperreports.transformations;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

import dev.igorartsoft.hierarchical.data.xml.jasperreports.model.Band;
import dev.igorartsoft.hierarchical.data.xml.jasperreports.model.JasperReport;
import dev.igorartsoft.hierarchical.data.xml.jasperreports.model.LabelValues;
import dev.igorartsoft.hierarchical.data.xml.jasperreports.model.Rectangle;
import dev.igorartsoft.hierarchical.data.xml.jasperreports.model.ReportElement;
import dev.igorartsoft.hierarchical.data.xml.jasperreports.model.SortableField;
import dev.igorartsoft.hierarchical.data.xml.jasperreports.model.StaticText;
import dev.igorartsoft.hierarchical.data.xml.jasperreports.model.TextField;

/**
 * 
 * This class does complex transformations of specific jasper xml files.
 * 
 * Original jasper file contains xml elements in random order.
 * Those xml elements need to be reallocated within xml file, based on custom logical reading order for PDF AODA compliance.
 * @see dev.igorartsoft.hierarchical.data.xml.jasperreports.transformations.JasperReportsTransformator.#doCustomizedSorting() 
 *  for details of implemented custom logical reading order. 
 * 
 * Some organizations only concern with HTML portion of AODA compliance, but it's not enough.
 * People, who can't read online report, need to convey a meaning of PDF online report by hearing the content.
 * The information from the report must be in logical reading order.
 * 
 * This program makes one step ahead to addresses PDF AODA compliance for online reports, dynamically generated by JEE web applications.
 *   
 * AODA compliance means (Accessibility for Ontarians with Disabilities Act). @see https://www.aoda.ca/ for more details.
 * AODA based on Web Content Accessibility Guidelines (WCAG) 2.0 standard. @see https://en.wikipedia.org/wiki/Web_Content_Accessibility_Guidelines
 * 
 * Console output contains Output of intermediate processing results, to help understand programming logic. 
 * 
 * @author 	Igor Artimenko (igorart7@gmail.com)
 * @version 1.0.0 Initial 
 * 
 *
 */
public class JasperReportsTransformator extends BaseCustomTransformator {

	private int overallRectangularElements = 0;
	
	public static void main(String[] args) {
	    
		String[] filesToParse = new String[]{ "DriverCopy" };
		
		JasperReportsTransformator jasperReportsTransformator = new JasperReportsTransformator();
		CustomTransformationValidator xmlValidator = new CustomTransformationValidator();
		
		for (int i = 0; i < filesToParse.length; i++) {
			
			try {
				
				System.out.println( "Started processing file: " + filesToParse[i] );
				
				jasperReportsTransformator.process( filesToParse[i] );	
				xmlValidator.validateNewAndOriginal( filesToParse[i], filesToParse[i] );
				
				System.out.println( SEPARATOR );
				System.out.println( "Finished processing file: " + filesToParse[i] );
				System.out.println( SEPARATOR );
				
			} catch (Exception e) {
				System.out.println( filesToParse[i] + " was not processed" );
				e.printStackTrace();
			}
				
		}
		
	}

	/**
	 * 
	 * High level explanation of custom order algorithm.
	 * 
	 * Typical logical reading order is from left to right top to bottom one (z order).
	 * 
	 * Our custom logical reading order implemented here is totally different.
	 * 
	 * Step 1.
	 * There are 6 rectangular areas in the center of each report and 2 rectangular areas on the left and on the right sides of the report.
	 * 6 is not a constant. Program dynamically identifies those number of such areas.
	 * 
	 * Step 2.
	 * The program identifies and groups parced xml elements into one of those specific areas. 
	 * 
	 * Step 3.
	 * For each of the areas, program identifies pairs of which xml element is a label and which is a matching value. 
	 * Further matching pairs ordered in z order. 
	 * 
	 */
	@Override
	public void doCustomizedSorting( JasperReport jasperReport ) {
		
		sortBandCustomized( jasperReport.getPageHeader().getBand() );			
		sortBandCustomized( jasperReport.getPageFooter().getBand() );

	} 
	
	void sortBandCustomized(Band band) {
			
		Rectangle[] allRectangles = band.getRectangle();
				
		if( allRectangles != null ){
			
			Arrays.sort( allRectangles, xmlElementComparator );
			
			List<Rectangle> areaRectangles = new ArrayList<Rectangle>();  
			for (Rectangle rectangle : allRectangles) {
				if( rectangle.getRadius() != null && !rectangle.getRadius().trim().isEmpty() ){
					areaRectangles.add( rectangle );
				}
			}
			
			if( areaRectangles.size() > 0 ){
				
				Map<ReportElement, List<SortableField>> rectangleGroups = new TreeMap<ReportElement, List<SortableField>>();
				areaRectangles.forEach( rectangle -> {
					rectangleGroups.put( rectangle.getReportElement(), new ArrayList<SortableField>() );
				});
				
				TextField[] textFields = band.getTextField();
				if( textFields != null ){
					Arrays.sort( textFields, xmlElementComparator );	
				}
				System.out.printf( "TextField[] elements extracted from file: %d \n", textFields.length );
				System.out.println( SEPARATOR );
				
				StaticText[] staticText = band.getStaticText();
				if( staticText != null ){
					Arrays.sort( staticText, xmlElementComparator );	
				}
				System.out.printf( "StaticText[] elements extracted from file: %d \n", staticText.length );
				System.out.println( SEPARATOR );
				
				// Other elements, which did not fit into other areas.
				List<SortableField> otherSortableFields = new ArrayList<SortableField>();
				List<LabelValues> allLabelValues = new ArrayList<LabelValues>();
				
				int maxTextLength = 0; 
				
				// Allocate elements into appropriate groups
				if( staticText != null ){					
					for (int i = 0; i < staticText.length; i++) {	
						allocateReportElementToRectangleGroups( staticText[i], rectangleGroups, otherSortableFields );	
						
						if( staticText[i].getText() != null &&  maxTextLength <= staticText[i].getText().getContent().length() ){
							maxTextLength = staticText[i].getText().getContent().length();
						}
					}					
				}
				
				if( textFields != null ){					
					for (int i = 0; i < textFields.length; i++) {						
						allocateReportElementToRectangleGroups( textFields[i], rectangleGroups, otherSortableFields );	
						if( textFields[i].getTextFieldExpression() != null &&  maxTextLength <= textFields[i].getTextFieldExpression().getContent().length() ){
							maxTextLength = textFields[i].getTextFieldExpression().getContent().length();
						}
					}					
				}				
								
				final String formatString = ( maxTextLength > 0 ) ? "%-" + maxTextLength + "s" : "%-55s";
				String formatStringGroup = "%-" + ( maxTextLength - 3 ) + "s";
				
				overallRectangularElements = 0;
				
				rectangleGroups.entrySet().forEach( currentGroup -> {
					
					ReportElement groupDimentions = currentGroup.getKey();
					List<SortableField> groupElements = currentGroup.getValue();					
					overallRectangularElements += ( groupElements != null ? groupElements.size() : 0 );
					
					showGroupElements( "Rectangular:", groupElements, formatString, formatStringGroup, groupDimentions );
					accumulateCurrentGroupLabelValues( allLabelValues, groupElements );
					
				});

				
				showGroupElements( "Other", otherSortableFields, formatString, null, null );
				accumulateOtherRectangulars( allLabelValues, otherSortableFields );

				band.setLabelValues( allLabelValues.toArray( new LabelValues[ allLabelValues.size() ] ) );
				band.setTextField( null );
				band.setStaticText( null );
							
				System.out.println( "Total Count of All processed elements in the Rectangels for the Band=" + ( overallRectangularElements + ( otherSortableFields != null ? otherSortableFields.size() : 0 ) ) );
				System.out.println( SEPARATOR );
				LabelValues[] labelValues = band.getLabelValues();
				
				long totalValuesBandCustomized = allLabelValues.stream().filter( labelValue-> labelValue.getStaticText() != null ).count();
				
				int totalTextFields = countTextFields( labelValues );
				System.out.println( "Total after processing band LabelValues " + totalValuesBandCustomized + " totalTextFields " + totalTextFields + 
									" labelValues.length " + labelValues.length );
				System.out.println( SEPARATOR );
				
			}
			
		}

	}
		
	private void allocateReportElementToRectangleGroups( SortableField currSortableField, 
			Map<ReportElement, List<SortableField>> rectangleGroups, List<SortableField> otherSortableFields) {
		
		boolean wasElementAllocated = false;
		ReportElement currReportElement = currSortableField.getReportElement();
		
		// Find the first rectangleGroup where this element belongs to and allocate it to that group.
		for (ReportElement currentGroup: rectangleGroups.keySet()) {

			int intX = currentGroup.getIntX();
			int intY = currentGroup.getIntY();
			int intWidth = currentGroup.getIntWidth();
			int intHeight = currentGroup.getIntHeight();
			
			// Compare that currReportElement is inside of this group
			// If yes that add to current group and exit
			// Otherwise check through the rest of the groups
			if( ( intY <= currReportElement.getIntY() && currReportElement.getIntY() < intY + intHeight ) &&
				( intX <= currReportElement.getIntX() && currReportElement.getIntX() < intX + intWidth ) ) {
				
			 	rectangleGroups.get( currentGroup ).add( currSortableField );				
				wasElementAllocated = true;
				break;
				
			}
			
		}
		
		if( !wasElementAllocated ){
			otherSortableFields.add( currSortableField );
		}
	}
	
	/**
	 * The method utilizes specific report layout, to help combine together elements of the area.
	 * 
	 * @param allLabelValues Collection of All LabelValues objects for entire report
	 * @param otherSortableField Collection of elements which belongs to specific rectangular. 
	 * 						If it's instanceof StaticText then it's considered as label. 
	 * 						If it's sortableField instanceof TextField then it's considered a value. 
	 * 
	 */
	void accumulateOtherRectangulars(List<LabelValues> allLabelValues, List<SortableField> otherSortableField ) {
		
		Rectangle leftSideRectangle = new Rectangle();
		ReportElement leftReportElement = new ReportElement();
		leftReportElement.setX( "0" );
		leftReportElement.setY( "60" );
		leftReportElement.setWidth( "64" );
		leftReportElement.setHeight( "395" );				
		leftSideRectangle.setReportElement( leftReportElement );
		
		Rectangle rightSideRectangle = new Rectangle();				
		ReportElement rightReportElement = new ReportElement();
		rightReportElement.setX( "548" );
		rightReportElement.setY( "35" );
		rightReportElement.setWidth( "40" );
		rightReportElement.setHeight( "406" );				
		rightSideRectangle.setReportElement( rightReportElement );			

		List<SortableField> leftSideElements = new ArrayList<SortableField>();
		List<SortableField> rightSideElements = new ArrayList<SortableField>();
		List<SortableField> otherSideElements = new ArrayList<SortableField>();
		
		for ( SortableField sortableField : otherSortableField ) {
			
			ReportElement reportElement = sortableField.getReportElement();
			
			if( ( leftReportElement.getIntY() <= reportElement.getIntY() && reportElement.getIntY()<= leftReportElement.getIntY() + leftReportElement.getIntHeight() ) && 
			    ( leftReportElement.getIntX() <= reportElement.getIntX() && reportElement.getIntX()<= leftReportElement.getIntX() + leftReportElement.getIntWidth() ) ){
				leftSideElements.add( sortableField );
			}
			else if( ( rightReportElement.getIntY() <= reportElement.getIntY() && reportElement.getIntY()<= rightReportElement.getIntY() + rightReportElement.getIntHeight() ) && 
				  ( rightReportElement.getIntX() <= reportElement.getIntX() && reportElement.getIntX()<= rightReportElement.getIntX() + rightReportElement.getIntWidth() ) ){
				rightSideElements.add( sortableField );
			}
			else {
				otherSideElements.add( sortableField );
			}
			
		}

		accumulateOtherGroupLabelValues( allLabelValues, leftSideElements );
		accumulateOtherGroupLabelValues( allLabelValues, rightSideElements );
		accumulateOtherGroupLabelValues( allLabelValues, otherSideElements );
		
	}
}